/* 
 * @(#)State.java        1.0 15/06/18
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "openconfig-notificaions", revision: "2018-06-06".
 */

package com.nokia.eml.yang.openconfigNotificaions.systemNotification.update.system.processes.process;

import com.nokia.eml.yang.openconfigProcmon.OcProc;
import com.nokia.eml.yang.openconfigTypes.Percentage;
import com.nokia.eml.yang.openconfigTypes.Timeticks64;
import com.tailf.jnc.Element;
import com.tailf.jnc.ElementLeafListValueIterator;
import com.tailf.jnc.JNCException;
import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt64;

import java.math.BigInteger;

/**
 * This class represents an element from 
 * the namespace http://openconfig.net/yang/openconfig-notificaions
 * generated to "src/com/nokia/eml/yang/openconfigNotificaions/systemNotification/update/system/processes/process/state"
 * <p>
 * See line 73 in
 * /root/nokia-yang/system/openconfig-procmon.yang
 *
 * @version 1.0 2018-06-15
 * @author Auto Generated
 */
public class State extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty State object.
     */
    public State() {
        super(OcProc.NAMESPACE, "state");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public State clone() {
        return (State)cloneContent(new State());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public State cloneShallow() {
        return (State)cloneShallowContent(new State());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "pid",
            "name",
            "args",
            "start-time",
            "uptime",
            "cpu-usage-user",
            "cpu-usage-system",
            "cpu-utilization",
            "memory-usage",
            "memory-utilization",
        };
    }

    /* Access methods for optional leaf child: "pid". */

    /**
     * Gets the value for child leaf "pid".
     * @return The value of the leaf.
     */
    public YangUInt64 getPidValue() throws JNCException {
        return (YangUInt64)getValue("pid");
    }

    /**
     * Sets the value for child leaf "pid",
     * using instance of generated typedef class.
     * @param pidValue The value to set.
     * @param pidValue used during instantiation.
     */
    public void setPidValue(YangUInt64 pidValue) throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "pid",
            pidValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "pid",
     * using Java primitive values.
     * @param pidValue used during instantiation.
     */
    public void setPidValue(BigInteger pidValue) throws JNCException {
        setPidValue(new YangUInt64(pidValue));
    }

    /**
     * Sets the value for child leaf "pid",
     * using a String value.
     * @param pidValue used during instantiation.
     */
    public void setPidValue(String pidValue) throws JNCException {
        setPidValue(new YangUInt64(pidValue));
    }

    /**
     * Unsets the value for child leaf "pid".
     */
    public void unsetPidValue() throws JNCException {
        delete("pid");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "pid" leaf will not have a value.
     */
    public void addPid() throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "pid",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "pid" with operation "replace".
     */
    public void markPidReplace() throws JNCException {
        markLeafReplace("pid");
    }

    /**
     * Marks the leaf "pid" with operation "merge".
     */
    public void markPidMerge() throws JNCException {
        markLeafMerge("pid");
    }

    /**
     * Marks the leaf "pid" with operation "create".
     */
    public void markPidCreate() throws JNCException {
        markLeafCreate("pid");
    }

    /**
     * Marks the leaf "pid" with operation "delete".
     */
    public void markPidDelete() throws JNCException {
        markLeafDelete("pid");
    }

    /* Access methods for optional leaf child: "name". */

    /**
     * Gets the value for child leaf "name".
     * @return The value of the leaf.
     */
    public YangString getNameValue() throws JNCException {
        return (YangString)getValue("name");
    }

    /**
     * Sets the value for child leaf "name",
     * using instance of generated typedef class.
     * @param nameValue The value to set.
     * @param nameValue used during instantiation.
     */
    public void setNameValue(YangString nameValue) throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "name",
            nameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "name",
     * using a String value.
     * @param nameValue used during instantiation.
     */
    public void setNameValue(String nameValue) throws JNCException {
        setNameValue(new YangString(nameValue));
    }

    /**
     * Unsets the value for child leaf "name".
     */
    public void unsetNameValue() throws JNCException {
        delete("name");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "name" leaf will not have a value.
     */
    public void addName() throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "name",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "name" with operation "replace".
     */
    public void markNameReplace() throws JNCException {
        markLeafReplace("name");
    }

    /**
     * Marks the leaf "name" with operation "merge".
     */
    public void markNameMerge() throws JNCException {
        markLeafMerge("name");
    }

    /**
     * Marks the leaf "name" with operation "create".
     */
    public void markNameCreate() throws JNCException {
        markLeafCreate("name");
    }

    /**
     * Marks the leaf "name" with operation "delete".
     */
    public void markNameDelete() throws JNCException {
        markLeafDelete("name");
    }

    /* Access methods for optional leaf-list child: "args". */

    /**
     * Iterator method for the leaf-list "args".
     * @return An iterator for the leaf-list.
     */
    public ElementLeafListValueIterator argsIterator() {
        return new ElementLeafListValueIterator(children, "args");
    }

    /**
     * Sets the value for child leaf-list "args",
     * using instance of generated typedef class.
     * @param argsValue The value to set.
     * @param argsValue used during instantiation.
     */
    public void setArgsValue(YangString argsValue) throws JNCException {
        setLeafListValue(OcProc.NAMESPACE,
            "args",
            argsValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf-list "args",
     * using a String value.
     * @param argsValue used during instantiation.
     */
    public void setArgsValue(String argsValue) throws JNCException {
        setArgsValue(new YangString(argsValue));
    }

    /**
     * Deletes leaf-list entry "args".
     * @param argsValue Value to delete.
     */
    public void deleteArgs(YangString argsValue) throws JNCException {
        String path = "args[argsValue]";
        delete(path);
    }

    /**
     * Deletes leaf-list entry "args".
     * The value is specified as a string.
     * @param argsValue Value to delete.
     */
    public void deleteArgs(String argsValue) throws JNCException {
        String path = "args[argsValue]";
        delete(path);
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "args" leaf-list will not have a value.
     */
    public void addArgs() throws JNCException {
        setLeafListValue(OcProc.NAMESPACE,
            "args",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf-list "args" with operation "replace".
     * @param argsValue The value to mark
     */
    public void markArgsReplace(YangString argsValue) throws JNCException {
        markLeafReplace("args[name='" + argsValue + "']");
    }

    /**
     * Marks the leaf-list "args" with operation "merge".
     * @param argsValue The value to mark
     */
    public void markArgsMerge(YangString argsValue) throws JNCException {
        markLeafMerge("args[name='" + argsValue + "']");
    }

    /**
     * Marks the leaf-list "args" with operation "create".
     * @param argsValue The value to mark
     */
    public void markArgsCreate(YangString argsValue) throws JNCException {
        markLeafCreate("args[name='" + argsValue + "']");
    }

    /**
     * Marks the leaf-list "args" with operation "delete".
     * @param argsValue The value to mark
     */
    public void markArgsDelete(YangString argsValue) throws JNCException {
        markLeafDelete("args[name='" + argsValue + "']");
    }

    /* Access methods for optional leaf child: "start-time". */

    /**
     * Gets the value for child leaf "start-time".
     * @return The value of the leaf.
     */
    public YangUInt64 getStartTimeValue() throws JNCException {
        return (YangUInt64)getValue("start-time");
    }

    /**
     * Sets the value for child leaf "start-time",
     * using instance of generated typedef class.
     * @param startTimeValue The value to set.
     * @param startTimeValue used during instantiation.
     */
    public void setStartTimeValue(YangUInt64 startTimeValue)
            throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "start-time",
            startTimeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "start-time",
     * using Java primitive values.
     * @param startTimeValue used during instantiation.
     */
    public void setStartTimeValue(BigInteger startTimeValue)
            throws JNCException {
        setStartTimeValue(new YangUInt64(startTimeValue));
    }

    /**
     * Sets the value for child leaf "start-time",
     * using a String value.
     * @param startTimeValue used during instantiation.
     */
    public void setStartTimeValue(String startTimeValue) throws JNCException {
        setStartTimeValue(new YangUInt64(startTimeValue));
    }

    /**
     * Unsets the value for child leaf "start-time".
     */
    public void unsetStartTimeValue() throws JNCException {
        delete("start-time");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "start-time" leaf will not have a value.
     */
    public void addStartTime() throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "start-time",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "start-time" with operation "replace".
     */
    public void markStartTimeReplace() throws JNCException {
        markLeafReplace("startTime");
    }

    /**
     * Marks the leaf "start-time" with operation "merge".
     */
    public void markStartTimeMerge() throws JNCException {
        markLeafMerge("startTime");
    }

    /**
     * Marks the leaf "start-time" with operation "create".
     */
    public void markStartTimeCreate() throws JNCException {
        markLeafCreate("startTime");
    }

    /**
     * Marks the leaf "start-time" with operation "delete".
     */
    public void markStartTimeDelete() throws JNCException {
        markLeafDelete("startTime");
    }

    /* Access methods for optional leaf child: "uptime". */

    /**
     * Gets the value for child leaf "uptime".
     * @return The value of the leaf.
     */
    public Timeticks64 getUptimeValue() throws JNCException {
        return (Timeticks64)getValue("uptime");
    }

    /**
     * Sets the value for child leaf "uptime",
     * using a JNC type value.
     * @param uptimeValue The value to set.
     * @param uptimeValue used during instantiation.
     */
    public void setUptimeValue(Timeticks64 uptimeValue) throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "uptime",
            uptimeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "uptime",
     * using Java primitive values.
     * @param uptimeValue used during instantiation.
     */
    public void setUptimeValue(BigInteger uptimeValue) throws JNCException {
        setUptimeValue(new Timeticks64(uptimeValue));
    }

    /**
     * Sets the value for child leaf "uptime",
     * using a String value.
     * @param uptimeValue used during instantiation.
     */
    public void setUptimeValue(String uptimeValue) throws JNCException {
        setUptimeValue(new Timeticks64(uptimeValue));
    }

    /**
     * Unsets the value for child leaf "uptime".
     */
    public void unsetUptimeValue() throws JNCException {
        delete("uptime");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "uptime" leaf will not have a value.
     */
    public void addUptime() throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "uptime",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "uptime" with operation "replace".
     */
    public void markUptimeReplace() throws JNCException {
        markLeafReplace("uptime");
    }

    /**
     * Marks the leaf "uptime" with operation "merge".
     */
    public void markUptimeMerge() throws JNCException {
        markLeafMerge("uptime");
    }

    /**
     * Marks the leaf "uptime" with operation "create".
     */
    public void markUptimeCreate() throws JNCException {
        markLeafCreate("uptime");
    }

    /**
     * Marks the leaf "uptime" with operation "delete".
     */
    public void markUptimeDelete() throws JNCException {
        markLeafDelete("uptime");
    }

    /* Access methods for optional leaf child: "cpu-usage-user". */

    /**
     * Gets the value for child leaf "cpu-usage-user".
     * @return The value of the leaf.
     */
    public Timeticks64 getCpuUsageUserValue() throws JNCException {
        return (Timeticks64)getValue("cpu-usage-user");
    }

    /**
     * Sets the value for child leaf "cpu-usage-user",
     * using a JNC type value.
     * @param cpuUsageUserValue The value to set.
     * @param cpuUsageUserValue used during instantiation.
     */
    public void setCpuUsageUserValue(Timeticks64 cpuUsageUserValue)
            throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "cpu-usage-user",
            cpuUsageUserValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "cpu-usage-user",
     * using Java primitive values.
     * @param cpuUsageUserValue used during instantiation.
     */
    public void setCpuUsageUserValue(BigInteger cpuUsageUserValue)
            throws JNCException {
        setCpuUsageUserValue(new Timeticks64(cpuUsageUserValue));
    }

    /**
     * Sets the value for child leaf "cpu-usage-user",
     * using a String value.
     * @param cpuUsageUserValue used during instantiation.
     */
    public void setCpuUsageUserValue(String cpuUsageUserValue)
            throws JNCException {
        setCpuUsageUserValue(new Timeticks64(cpuUsageUserValue));
    }

    /**
     * Unsets the value for child leaf "cpu-usage-user".
     */
    public void unsetCpuUsageUserValue() throws JNCException {
        delete("cpu-usage-user");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "cpu-usage-user" leaf will not have a value.
     */
    public void addCpuUsageUser() throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "cpu-usage-user",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "cpu-usage-user" with operation "replace".
     */
    public void markCpuUsageUserReplace() throws JNCException {
        markLeafReplace("cpuUsageUser");
    }

    /**
     * Marks the leaf "cpu-usage-user" with operation "merge".
     */
    public void markCpuUsageUserMerge() throws JNCException {
        markLeafMerge("cpuUsageUser");
    }

    /**
     * Marks the leaf "cpu-usage-user" with operation "create".
     */
    public void markCpuUsageUserCreate() throws JNCException {
        markLeafCreate("cpuUsageUser");
    }

    /**
     * Marks the leaf "cpu-usage-user" with operation "delete".
     */
    public void markCpuUsageUserDelete() throws JNCException {
        markLeafDelete("cpuUsageUser");
    }

    /* Access methods for optional leaf child: "cpu-usage-system". */

    /**
     * Gets the value for child leaf "cpu-usage-system".
     * @return The value of the leaf.
     */
    public Timeticks64 getCpuUsageSystemValue() throws JNCException {
        return (Timeticks64)getValue("cpu-usage-system");
    }

    /**
     * Sets the value for child leaf "cpu-usage-system",
     * using a JNC type value.
     * @param cpuUsageSystemValue The value to set.
     * @param cpuUsageSystemValue used during instantiation.
     */
    public void setCpuUsageSystemValue(Timeticks64 cpuUsageSystemValue)
            throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "cpu-usage-system",
            cpuUsageSystemValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "cpu-usage-system",
     * using Java primitive values.
     * @param cpuUsageSystemValue used during instantiation.
     */
    public void setCpuUsageSystemValue(BigInteger cpuUsageSystemValue)
            throws JNCException {
        setCpuUsageSystemValue(new Timeticks64(cpuUsageSystemValue));
    }

    /**
     * Sets the value for child leaf "cpu-usage-system",
     * using a String value.
     * @param cpuUsageSystemValue used during instantiation.
     */
    public void setCpuUsageSystemValue(String cpuUsageSystemValue)
            throws JNCException {
        setCpuUsageSystemValue(new Timeticks64(cpuUsageSystemValue));
    }

    /**
     * Unsets the value for child leaf "cpu-usage-system".
     */
    public void unsetCpuUsageSystemValue() throws JNCException {
        delete("cpu-usage-system");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "cpu-usage-system" leaf will not have a value.
     */
    public void addCpuUsageSystem() throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "cpu-usage-system",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "cpu-usage-system" with operation "replace".
     */
    public void markCpuUsageSystemReplace() throws JNCException {
        markLeafReplace("cpuUsageSystem");
    }

    /**
     * Marks the leaf "cpu-usage-system" with operation "merge".
     */
    public void markCpuUsageSystemMerge() throws JNCException {
        markLeafMerge("cpuUsageSystem");
    }

    /**
     * Marks the leaf "cpu-usage-system" with operation "create".
     */
    public void markCpuUsageSystemCreate() throws JNCException {
        markLeafCreate("cpuUsageSystem");
    }

    /**
     * Marks the leaf "cpu-usage-system" with operation "delete".
     */
    public void markCpuUsageSystemDelete() throws JNCException {
        markLeafDelete("cpuUsageSystem");
    }

    /* Access methods for optional leaf child: "cpu-utilization". */

    /**
     * Gets the value for child leaf "cpu-utilization".
     * @return The value of the leaf.
     */
    public Percentage getCpuUtilizationValue() throws JNCException {
        return (Percentage)getValue("cpu-utilization");
    }

    /**
     * Sets the value for child leaf "cpu-utilization",
     * using a JNC type value.
     * @param cpuUtilizationValue The value to set.
     * @param cpuUtilizationValue used during instantiation.
     */
    public void setCpuUtilizationValue(Percentage cpuUtilizationValue)
            throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "cpu-utilization",
            cpuUtilizationValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "cpu-utilization",
     * using Java primitive values.
     * @param cpuUtilizationValue used during instantiation.
     */
    public void setCpuUtilizationValue(short cpuUtilizationValue)
            throws JNCException {
        setCpuUtilizationValue(new Percentage(cpuUtilizationValue));
    }

    /**
     * Sets the value for child leaf "cpu-utilization",
     * using a String value.
     * @param cpuUtilizationValue used during instantiation.
     */
    public void setCpuUtilizationValue(String cpuUtilizationValue)
            throws JNCException {
        setCpuUtilizationValue(new Percentage(cpuUtilizationValue));
    }

    /**
     * Unsets the value for child leaf "cpu-utilization".
     */
    public void unsetCpuUtilizationValue() throws JNCException {
        delete("cpu-utilization");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "cpu-utilization" leaf will not have a value.
     */
    public void addCpuUtilization() throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "cpu-utilization",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "cpu-utilization" with operation "replace".
     */
    public void markCpuUtilizationReplace() throws JNCException {
        markLeafReplace("cpuUtilization");
    }

    /**
     * Marks the leaf "cpu-utilization" with operation "merge".
     */
    public void markCpuUtilizationMerge() throws JNCException {
        markLeafMerge("cpuUtilization");
    }

    /**
     * Marks the leaf "cpu-utilization" with operation "create".
     */
    public void markCpuUtilizationCreate() throws JNCException {
        markLeafCreate("cpuUtilization");
    }

    /**
     * Marks the leaf "cpu-utilization" with operation "delete".
     */
    public void markCpuUtilizationDelete() throws JNCException {
        markLeafDelete("cpuUtilization");
    }

    /* Access methods for optional leaf child: "memory-usage". */

    /**
     * Gets the value for child leaf "memory-usage".
     * @return The value of the leaf.
     */
    public YangUInt64 getMemoryUsageValue() throws JNCException {
        return (YangUInt64)getValue("memory-usage");
    }

    /**
     * Sets the value for child leaf "memory-usage",
     * using instance of generated typedef class.
     * @param memoryUsageValue The value to set.
     * @param memoryUsageValue used during instantiation.
     */
    public void setMemoryUsageValue(YangUInt64 memoryUsageValue)
            throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "memory-usage",
            memoryUsageValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "memory-usage",
     * using Java primitive values.
     * @param memoryUsageValue used during instantiation.
     */
    public void setMemoryUsageValue(BigInteger memoryUsageValue)
            throws JNCException {
        setMemoryUsageValue(new YangUInt64(memoryUsageValue));
    }

    /**
     * Sets the value for child leaf "memory-usage",
     * using a String value.
     * @param memoryUsageValue used during instantiation.
     */
    public void setMemoryUsageValue(String memoryUsageValue)
            throws JNCException {
        setMemoryUsageValue(new YangUInt64(memoryUsageValue));
    }

    /**
     * Unsets the value for child leaf "memory-usage".
     */
    public void unsetMemoryUsageValue() throws JNCException {
        delete("memory-usage");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "memory-usage" leaf will not have a value.
     */
    public void addMemoryUsage() throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "memory-usage",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "memory-usage" with operation "replace".
     */
    public void markMemoryUsageReplace() throws JNCException {
        markLeafReplace("memoryUsage");
    }

    /**
     * Marks the leaf "memory-usage" with operation "merge".
     */
    public void markMemoryUsageMerge() throws JNCException {
        markLeafMerge("memoryUsage");
    }

    /**
     * Marks the leaf "memory-usage" with operation "create".
     */
    public void markMemoryUsageCreate() throws JNCException {
        markLeafCreate("memoryUsage");
    }

    /**
     * Marks the leaf "memory-usage" with operation "delete".
     */
    public void markMemoryUsageDelete() throws JNCException {
        markLeafDelete("memoryUsage");
    }

    /* Access methods for optional leaf child: "memory-utilization". */

    /**
     * Gets the value for child leaf "memory-utilization".
     * @return The value of the leaf.
     */
    public Percentage getMemoryUtilizationValue() throws JNCException {
        return (Percentage)getValue("memory-utilization");
    }

    /**
     * Sets the value for child leaf "memory-utilization",
     * using a JNC type value.
     * @param memoryUtilizationValue The value to set.
     * @param memoryUtilizationValue used during instantiation.
     */
    public void setMemoryUtilizationValue(Percentage memoryUtilizationValue)
            throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "memory-utilization",
            memoryUtilizationValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "memory-utilization",
     * using Java primitive values.
     * @param memoryUtilizationValue used during instantiation.
     */
    public void setMemoryUtilizationValue(short memoryUtilizationValue)
            throws JNCException {
        setMemoryUtilizationValue(new Percentage(memoryUtilizationValue));
    }

    /**
     * Sets the value for child leaf "memory-utilization",
     * using a String value.
     * @param memoryUtilizationValue used during instantiation.
     */
    public void setMemoryUtilizationValue(String memoryUtilizationValue)
            throws JNCException {
        setMemoryUtilizationValue(new Percentage(memoryUtilizationValue));
    }

    /**
     * Unsets the value for child leaf "memory-utilization".
     */
    public void unsetMemoryUtilizationValue() throws JNCException {
        delete("memory-utilization");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "memory-utilization" leaf will not have a value.
     */
    public void addMemoryUtilization() throws JNCException {
        setLeafValue(OcProc.NAMESPACE,
            "memory-utilization",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "memory-utilization" with operation "replace".
     */
    public void markMemoryUtilizationReplace() throws JNCException {
        markLeafReplace("memoryUtilization");
    }

    /**
     * Marks the leaf "memory-utilization" with operation "merge".
     */
    public void markMemoryUtilizationMerge() throws JNCException {
        markLeafMerge("memoryUtilization");
    }

    /**
     * Marks the leaf "memory-utilization" with operation "create".
     */
    public void markMemoryUtilizationCreate() throws JNCException {
        markLeafCreate("memoryUtilization");
    }

    /**
     * Marks the leaf "memory-utilization" with operation "delete".
     */
    public void markMemoryUtilizationDelete() throws JNCException {
        markLeafDelete("memoryUtilization");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
