/* 
 * @(#)JInterface.java        1.0 15/06/18
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "ietf-interfaces", revision: "2018-02-20".
 */

package com.nokia.eml.yang.ietfInterfaces.interfaces;

import com.nokia.eml.yang.ietfInterfaces.InterfaceRef;
import com.nokia.eml.yang.ietfInterfaces.JIf;
import com.nokia.eml.yang.ietfInterfaces.interfaces.interface_.Statistics;
import com.nokia.eml.yang.ietfYangTypes.DateAndTime;
import com.nokia.eml.yang.ietfYangTypes.Gauge64;
import com.nokia.eml.yang.ietfYangTypes.PhysAddress;
import com.tailf.jnc.Element;
import com.tailf.jnc.ElementLeafListValueIterator;
import com.tailf.jnc.JNCException;
import com.tailf.jnc.Leaf;
import com.tailf.jnc.NodeSet;
import com.tailf.jnc.YangBoolean;
import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangIdentityref;
import com.tailf.jnc.YangInt32;
import com.tailf.jnc.YangString;

import java.math.BigInteger;

/**
 * This class represents an element from 
 * the namespace urn:ietf:params:xml:ns:yang:ietf-interfaces
 * generated to "src/com/nokia/eml/yang/ietfInterfaces/interfaces/interface"
 * <p>
 * See line 106 in
 * /root/pyang-pyang-1.7.5/modules/ietf/ietf-interfaces.yang
 *
 * @version 1.0 2018-06-15
 * @author Auto Generated
 */
public class JInterface extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Field for child container "statistics".
     */
    public Statistics statistics = null;

    /**
     * Constructor for an empty JInterface object.
     */
    public JInterface() {
        super(JIf.NAMESPACE, "interface");
    }

    /**
     * Constructor for an initialized JInterface object,
     * 
     * @param nameValue Key argument of child.
     */
    public JInterface(YangString nameValue) throws JNCException {
        super(JIf.NAMESPACE, "interface");
        Leaf name = new Leaf(JIf.NAMESPACE, "name");
        name.setValue(nameValue);
        insertChild(name, childrenNames());
    }

    /**
     * Constructor for an initialized JInterface object,
     * with String keys.
     * @param nameValue Key argument of child.
     */
    public JInterface(String nameValue) throws JNCException {
        super(JIf.NAMESPACE, "interface");
        Leaf name = new Leaf(JIf.NAMESPACE, "name");
        name.setValue(new YangString(nameValue));
        insertChild(name, childrenNames());
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public JInterface clone() {
        JInterface copy;
        try {
            copy = new JInterface(getNameValue().toString());
        } catch (JNCException e) {
            copy = null;
        }
        return (JInterface)cloneContent(copy);
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public JInterface cloneShallow() {
        JInterface copy;
        try {
            copy = new JInterface(getNameValue().toString());
        } catch (JNCException e) {
            copy = null;
        }
        return (JInterface)cloneShallowContent(copy);
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return new String[] {
            "name",
        };
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "name",
            "description",
            "type",
            "enabled",
            "link-up-down-trap-enable",
            "admin-status",
            "oper-status",
            "last-change",
            "if-index",
            "phys-address",
            "higher-layer-if",
            "lower-layer-if",
            "speed",
            "statistics",
        };
    }

    /* Access methods for leaf child: "name". */

    /**
     * Gets the value for child leaf "name".
     * @return The value of the leaf.
     */
    public YangString getNameValue() throws JNCException {
        return (YangString)getValue("name");
    }

    /**
     * Sets the value for child leaf "name",
     * using instance of generated typedef class.
     * @param nameValue The value to set.
     * @param nameValue used during instantiation.
     */
    public void setNameValue(YangString nameValue) throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "name",
            nameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "name",
     * using a String value.
     * @param nameValue used during instantiation.
     */
    public void setNameValue(String nameValue) throws JNCException {
        setNameValue(new YangString(nameValue));
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "name" leaf will not have a value.
     */
    public void addName() throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "name",
            null,
            childrenNames());
    }

    /* Access methods for optional leaf child: "description". */

    /**
     * Gets the value for child leaf "description".
     * @return The value of the leaf.
     */
    public YangString getDescriptionValue() throws JNCException {
        return (YangString)getValue("description");
    }

    /**
     * Sets the value for child leaf "description",
     * using instance of generated typedef class.
     * @param descriptionValue The value to set.
     * @param descriptionValue used during instantiation.
     */
    public void setDescriptionValue(YangString descriptionValue)
            throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "description",
            descriptionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "description",
     * using a String value.
     * @param descriptionValue used during instantiation.
     */
    public void setDescriptionValue(String descriptionValue)
            throws JNCException {
        setDescriptionValue(new YangString(descriptionValue));
    }

    /**
     * Unsets the value for child leaf "description".
     */
    public void unsetDescriptionValue() throws JNCException {
        delete("description");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "description" leaf will not have a value.
     */
    public void addDescription() throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "description",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "description" with operation "replace".
     */
    public void markDescriptionReplace() throws JNCException {
        markLeafReplace("description");
    }

    /**
     * Marks the leaf "description" with operation "merge".
     */
    public void markDescriptionMerge() throws JNCException {
        markLeafMerge("description");
    }

    /**
     * Marks the leaf "description" with operation "create".
     */
    public void markDescriptionCreate() throws JNCException {
        markLeafCreate("description");
    }

    /**
     * Marks the leaf "description" with operation "delete".
     */
    public void markDescriptionDelete() throws JNCException {
        markLeafDelete("description");
    }

    /* Access methods for optional leaf child: "type". */

    /**
     * Gets the value for child leaf "type".
     * @return The value of the leaf.
     */
    public YangIdentityref getTypeValue() throws JNCException {
        return (YangIdentityref)getValue("type");
    }

    /**
     * Sets the value for child leaf "type",
     * using instance of generated typedef class.
     * @param typeValue The value to set.
     * @param typeValue used during instantiation.
     */
    public void setTypeValue(YangIdentityref typeValue) throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "type",
            typeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "type",
     * using a String value.
     * @param typeValue used during instantiation.
     */
    public void setTypeValue(String typeValue) throws JNCException {
        setTypeValue(new YangIdentityref(typeValue));
    }

    /**
     * Unsets the value for child leaf "type".
     */
    public void unsetTypeValue() throws JNCException {
        delete("type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "type" leaf will not have a value.
     */
    public void addType() throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "type" with operation "replace".
     */
    public void markTypeReplace() throws JNCException {
        markLeafReplace("type");
    }

    /**
     * Marks the leaf "type" with operation "merge".
     */
    public void markTypeMerge() throws JNCException {
        markLeafMerge("type");
    }

    /**
     * Marks the leaf "type" with operation "create".
     */
    public void markTypeCreate() throws JNCException {
        markLeafCreate("type");
    }

    /**
     * Marks the leaf "type" with operation "delete".
     */
    public void markTypeDelete() throws JNCException {
        markLeafDelete("type");
    }

    /* Access methods for optional leaf child: "enabled". */

    /**
     * Gets the value for child leaf "enabled".
     * @return The value of the leaf.
     */
    public YangBoolean getEnabledValue() throws JNCException {
        YangBoolean enabled = (YangBoolean)getValue("enabled");
        if (enabled == null) {
            enabled = new YangBoolean("true");  // default
        }
        return enabled;
    }

    /**
     * Sets the value for child leaf "enabled",
     * using instance of generated typedef class.
     * @param enabledValue The value to set.
     * @param enabledValue used during instantiation.
     */
    public void setEnabledValue(YangBoolean enabledValue) throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "enabled",
            enabledValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "enabled",
     * using Java primitive values.
     * @param enabledValue used during instantiation.
     */
    public void setEnabledValue(Boolean enabledValue) throws JNCException {
        setEnabledValue(new YangBoolean(enabledValue));
    }

    /**
     * Sets the value for child leaf "enabled",
     * using a String value.
     * @param enabledValue used during instantiation.
     */
    public void setEnabledValue(String enabledValue) throws JNCException {
        setEnabledValue(new YangBoolean(enabledValue));
    }

    /**
     * Unsets the value for child leaf "enabled".
     */
    public void unsetEnabledValue() throws JNCException {
        delete("enabled");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "enabled" leaf will not have a value.
     */
    public void addEnabled() throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "enabled",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "enabled" with operation "replace".
     */
    public void markEnabledReplace() throws JNCException {
        markLeafReplace("enabled");
    }

    /**
     * Marks the leaf "enabled" with operation "merge".
     */
    public void markEnabledMerge() throws JNCException {
        markLeafMerge("enabled");
    }

    /**
     * Marks the leaf "enabled" with operation "create".
     */
    public void markEnabledCreate() throws JNCException {
        markLeafCreate("enabled");
    }

    /**
     * Marks the leaf "enabled" with operation "delete".
     */
    public void markEnabledDelete() throws JNCException {
        markLeafDelete("enabled");
    }

    /* Access methods for optional leaf child: "link-up-down-trap-enable". */

    /**
     * Gets the value for child leaf "link-up-down-trap-enable".
     * @return The value of the leaf.
     */
    public YangEnumeration getLinkUpDownTrapEnableValue() throws JNCException {
        return (YangEnumeration)getValue("link-up-down-trap-enable");
    }

    /**
     * Sets the value for child leaf "link-up-down-trap-enable",
     * using instance of generated typedef class.
     * @param linkUpDownTrapEnableValue The value to set.
     * @param linkUpDownTrapEnableValue used during instantiation.
     */
    public void setLinkUpDownTrapEnableValue(YangEnumeration linkUpDownTrapEnableValue)
            throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "link-up-down-trap-enable",
            linkUpDownTrapEnableValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "link-up-down-trap-enable",
     * using a String value.
     * @param linkUpDownTrapEnableValue used during instantiation.
     */
    public void setLinkUpDownTrapEnableValue(String linkUpDownTrapEnableValue)
            throws JNCException {
        setLinkUpDownTrapEnableValue(new YangEnumeration(linkUpDownTrapEnableValue, new String[] {
             "enabled",
             "disabled",
        }));
    }

    /**
     * Unsets the value for child leaf "link-up-down-trap-enable".
     */
    public void unsetLinkUpDownTrapEnableValue() throws JNCException {
        delete("link-up-down-trap-enable");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "link-up-down-trap-enable" leaf will not have a value.
     */
    public void addLinkUpDownTrapEnable() throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "link-up-down-trap-enable",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "link-up-down-trap-enable" with operation "replace".
     */
    public void markLinkUpDownTrapEnableReplace() throws JNCException {
        markLeafReplace("linkUpDownTrapEnable");
    }

    /**
     * Marks the leaf "link-up-down-trap-enable" with operation "merge".
     */
    public void markLinkUpDownTrapEnableMerge() throws JNCException {
        markLeafMerge("linkUpDownTrapEnable");
    }

    /**
     * Marks the leaf "link-up-down-trap-enable" with operation "create".
     */
    public void markLinkUpDownTrapEnableCreate() throws JNCException {
        markLeafCreate("linkUpDownTrapEnable");
    }

    /**
     * Marks the leaf "link-up-down-trap-enable" with operation "delete".
     */
    public void markLinkUpDownTrapEnableDelete() throws JNCException {
        markLeafDelete("linkUpDownTrapEnable");
    }

    /* Access methods for optional leaf child: "admin-status". */

    /**
     * Gets the value for child leaf "admin-status".
     * @return The value of the leaf.
     */
    public YangEnumeration getAdminStatusValue() throws JNCException {
        return (YangEnumeration)getValue("admin-status");
    }

    /**
     * Sets the value for child leaf "admin-status",
     * using instance of generated typedef class.
     * @param adminStatusValue The value to set.
     * @param adminStatusValue used during instantiation.
     */
    public void setAdminStatusValue(YangEnumeration adminStatusValue)
            throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "admin-status",
            adminStatusValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "admin-status",
     * using a String value.
     * @param adminStatusValue used during instantiation.
     */
    public void setAdminStatusValue(String adminStatusValue)
            throws JNCException {
        setAdminStatusValue(new YangEnumeration(adminStatusValue, new String[] {
             "up",
             "down",
             "testing",
        }));
    }

    /**
     * Unsets the value for child leaf "admin-status".
     */
    public void unsetAdminStatusValue() throws JNCException {
        delete("admin-status");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "admin-status" leaf will not have a value.
     */
    public void addAdminStatus() throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "admin-status",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "admin-status" with operation "replace".
     */
    public void markAdminStatusReplace() throws JNCException {
        markLeafReplace("adminStatus");
    }

    /**
     * Marks the leaf "admin-status" with operation "merge".
     */
    public void markAdminStatusMerge() throws JNCException {
        markLeafMerge("adminStatus");
    }

    /**
     * Marks the leaf "admin-status" with operation "create".
     */
    public void markAdminStatusCreate() throws JNCException {
        markLeafCreate("adminStatus");
    }

    /**
     * Marks the leaf "admin-status" with operation "delete".
     */
    public void markAdminStatusDelete() throws JNCException {
        markLeafDelete("adminStatus");
    }

    /* Access methods for optional leaf child: "oper-status". */

    /**
     * Gets the value for child leaf "oper-status".
     * @return The value of the leaf.
     */
    public YangEnumeration getOperStatusValue() throws JNCException {
        return (YangEnumeration)getValue("oper-status");
    }

    /**
     * Sets the value for child leaf "oper-status",
     * using instance of generated typedef class.
     * @param operStatusValue The value to set.
     * @param operStatusValue used during instantiation.
     */
    public void setOperStatusValue(YangEnumeration operStatusValue)
            throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "oper-status",
            operStatusValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "oper-status",
     * using a String value.
     * @param operStatusValue used during instantiation.
     */
    public void setOperStatusValue(String operStatusValue) throws JNCException {
        setOperStatusValue(new YangEnumeration(operStatusValue, new String[] {
             "up",
             "down",
             "testing",
             "unknown",
             "dormant",
             "not-present",
             "lower-layer-down",
        }));
    }

    /**
     * Unsets the value for child leaf "oper-status".
     */
    public void unsetOperStatusValue() throws JNCException {
        delete("oper-status");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "oper-status" leaf will not have a value.
     */
    public void addOperStatus() throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "oper-status",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "oper-status" with operation "replace".
     */
    public void markOperStatusReplace() throws JNCException {
        markLeafReplace("operStatus");
    }

    /**
     * Marks the leaf "oper-status" with operation "merge".
     */
    public void markOperStatusMerge() throws JNCException {
        markLeafMerge("operStatus");
    }

    /**
     * Marks the leaf "oper-status" with operation "create".
     */
    public void markOperStatusCreate() throws JNCException {
        markLeafCreate("operStatus");
    }

    /**
     * Marks the leaf "oper-status" with operation "delete".
     */
    public void markOperStatusDelete() throws JNCException {
        markLeafDelete("operStatus");
    }

    /* Access methods for optional leaf child: "last-change". */

    /**
     * Gets the value for child leaf "last-change".
     * @return The value of the leaf.
     */
    public DateAndTime getLastChangeValue() throws JNCException {
        return (DateAndTime)getValue("last-change");
    }

    /**
     * Sets the value for child leaf "last-change",
     * using a JNC type value.
     * @param lastChangeValue The value to set.
     * @param lastChangeValue used during instantiation.
     */
    public void setLastChangeValue(DateAndTime lastChangeValue)
            throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "last-change",
            lastChangeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "last-change",
     * using a String value.
     * @param lastChangeValue used during instantiation.
     */
    public void setLastChangeValue(String lastChangeValue) throws JNCException {
        setLastChangeValue(new DateAndTime(lastChangeValue));
    }

    /**
     * Unsets the value for child leaf "last-change".
     */
    public void unsetLastChangeValue() throws JNCException {
        delete("last-change");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "last-change" leaf will not have a value.
     */
    public void addLastChange() throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "last-change",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "last-change" with operation "replace".
     */
    public void markLastChangeReplace() throws JNCException {
        markLeafReplace("lastChange");
    }

    /**
     * Marks the leaf "last-change" with operation "merge".
     */
    public void markLastChangeMerge() throws JNCException {
        markLeafMerge("lastChange");
    }

    /**
     * Marks the leaf "last-change" with operation "create".
     */
    public void markLastChangeCreate() throws JNCException {
        markLeafCreate("lastChange");
    }

    /**
     * Marks the leaf "last-change" with operation "delete".
     */
    public void markLastChangeDelete() throws JNCException {
        markLeafDelete("lastChange");
    }

    /* Access methods for optional leaf child: "if-index". */

    /**
     * Gets the value for child leaf "if-index".
     * @return The value of the leaf.
     */
    public YangInt32 getIfIndexValue() throws JNCException {
        return (YangInt32)getValue("if-index");
    }

    /**
     * Sets the value for child leaf "if-index",
     * using instance of generated typedef class.
     * @param ifIndexValue The value to set.
     * @param ifIndexValue used during instantiation.
     */
    public void setIfIndexValue(YangInt32 ifIndexValue) throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "if-index",
            ifIndexValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "if-index",
     * using Java primitive values.
     * @param ifIndexValue used during instantiation.
     */
    public void setIfIndexValue(int ifIndexValue) throws JNCException {
        setIfIndexValue(new YangInt32(ifIndexValue));
    }

    /**
     * Sets the value for child leaf "if-index",
     * using a String value.
     * @param ifIndexValue used during instantiation.
     */
    public void setIfIndexValue(String ifIndexValue) throws JNCException {
        setIfIndexValue(new YangInt32(ifIndexValue));
    }

    /**
     * Unsets the value for child leaf "if-index".
     */
    public void unsetIfIndexValue() throws JNCException {
        delete("if-index");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "if-index" leaf will not have a value.
     */
    public void addIfIndex() throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "if-index",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "if-index" with operation "replace".
     */
    public void markIfIndexReplace() throws JNCException {
        markLeafReplace("ifIndex");
    }

    /**
     * Marks the leaf "if-index" with operation "merge".
     */
    public void markIfIndexMerge() throws JNCException {
        markLeafMerge("ifIndex");
    }

    /**
     * Marks the leaf "if-index" with operation "create".
     */
    public void markIfIndexCreate() throws JNCException {
        markLeafCreate("ifIndex");
    }

    /**
     * Marks the leaf "if-index" with operation "delete".
     */
    public void markIfIndexDelete() throws JNCException {
        markLeafDelete("ifIndex");
    }

    /* Access methods for optional leaf child: "phys-address". */

    /**
     * Gets the value for child leaf "phys-address".
     * @return The value of the leaf.
     */
    public PhysAddress getPhysAddressValue() throws JNCException {
        return (PhysAddress)getValue("phys-address");
    }

    /**
     * Sets the value for child leaf "phys-address",
     * using a JNC type value.
     * @param physAddressValue The value to set.
     * @param physAddressValue used during instantiation.
     */
    public void setPhysAddressValue(PhysAddress physAddressValue)
            throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "phys-address",
            physAddressValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "phys-address",
     * using a String value.
     * @param physAddressValue used during instantiation.
     */
    public void setPhysAddressValue(String physAddressValue)
            throws JNCException {
        setPhysAddressValue(new PhysAddress(physAddressValue));
    }

    /**
     * Unsets the value for child leaf "phys-address".
     */
    public void unsetPhysAddressValue() throws JNCException {
        delete("phys-address");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "phys-address" leaf will not have a value.
     */
    public void addPhysAddress() throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "phys-address",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "phys-address" with operation "replace".
     */
    public void markPhysAddressReplace() throws JNCException {
        markLeafReplace("physAddress");
    }

    /**
     * Marks the leaf "phys-address" with operation "merge".
     */
    public void markPhysAddressMerge() throws JNCException {
        markLeafMerge("physAddress");
    }

    /**
     * Marks the leaf "phys-address" with operation "create".
     */
    public void markPhysAddressCreate() throws JNCException {
        markLeafCreate("physAddress");
    }

    /**
     * Marks the leaf "phys-address" with operation "delete".
     */
    public void markPhysAddressDelete() throws JNCException {
        markLeafDelete("physAddress");
    }

    /* Access methods for optional leaf-list child: "higher-layer-if". */

    /**
     * Iterator method for the leaf-list "higher-layer-if".
     * @return An iterator for the leaf-list.
     */
    public ElementLeafListValueIterator higherLayerIfIterator() {
        return new ElementLeafListValueIterator(children, "higher-layer-if");
    }

    /**
     * Sets the value for child leaf-list "higher-layer-if",
     * using a JNC type value.
     * @param higherLayerIfValue The value to set.
     * @param higherLayerIfValue used during instantiation.
     */
    public void setHigherLayerIfValue(InterfaceRef higherLayerIfValue)
            throws JNCException {
        setLeafListValue(JIf.NAMESPACE,
            "higher-layer-if",
            higherLayerIfValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf-list "higher-layer-if",
     * using a String value.
     * @param higherLayerIfValue used during instantiation.
     */
    public void setHigherLayerIfValue(String higherLayerIfValue)
            throws JNCException {
        setHigherLayerIfValue(new InterfaceRef(higherLayerIfValue));
    }

    /**
     * Deletes leaf-list entry "higherLayerIf".
     * @param higherLayerIfValue Value to delete.
     */
    public void deleteHigherLayerIf(InterfaceRef higherLayerIfValue)
            throws JNCException {
        String path = "higherLayerIf[higherLayerIfValue]";
        delete(path);
    }

    /**
     * Deletes leaf-list entry "higherLayerIf".
     * The value is specified as a string.
     * @param higherLayerIfValue Value to delete.
     */
    public void deleteHigherLayerIf(String higherLayerIfValue)
            throws JNCException {
        String path = "higherLayerIf[higherLayerIfValue]";
        delete(path);
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "higher-layer-if" leaf-list will not have a value.
     */
    public void addHigherLayerIf() throws JNCException {
        setLeafListValue(JIf.NAMESPACE,
            "higher-layer-if",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf-list "higher-layer-if" with operation "replace".
     * @param higherLayerIfValue The value to mark
     */
    public void markHigherLayerIfReplace(InterfaceRef higherLayerIfValue)
            throws JNCException {
        markLeafReplace("higherLayerIf[name='" + higherLayerIfValue + "']");
    }

    /**
     * Marks the leaf-list "higher-layer-if" with operation "merge".
     * @param higherLayerIfValue The value to mark
     */
    public void markHigherLayerIfMerge(InterfaceRef higherLayerIfValue)
            throws JNCException {
        markLeafMerge("higherLayerIf[name='" + higherLayerIfValue + "']");
    }

    /**
     * Marks the leaf-list "higher-layer-if" with operation "create".
     * @param higherLayerIfValue The value to mark
     */
    public void markHigherLayerIfCreate(InterfaceRef higherLayerIfValue)
            throws JNCException {
        markLeafCreate("higherLayerIf[name='" + higherLayerIfValue + "']");
    }

    /**
     * Marks the leaf-list "higher-layer-if" with operation "delete".
     * @param higherLayerIfValue The value to mark
     */
    public void markHigherLayerIfDelete(InterfaceRef higherLayerIfValue)
            throws JNCException {
        markLeafDelete("higherLayerIf[name='" + higherLayerIfValue + "']");
    }

    /* Access methods for optional leaf-list child: "lower-layer-if". */

    /**
     * Iterator method for the leaf-list "lower-layer-if".
     * @return An iterator for the leaf-list.
     */
    public ElementLeafListValueIterator lowerLayerIfIterator() {
        return new ElementLeafListValueIterator(children, "lower-layer-if");
    }

    /**
     * Sets the value for child leaf-list "lower-layer-if",
     * using a JNC type value.
     * @param lowerLayerIfValue The value to set.
     * @param lowerLayerIfValue used during instantiation.
     */
    public void setLowerLayerIfValue(InterfaceRef lowerLayerIfValue)
            throws JNCException {
        setLeafListValue(JIf.NAMESPACE,
            "lower-layer-if",
            lowerLayerIfValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf-list "lower-layer-if",
     * using a String value.
     * @param lowerLayerIfValue used during instantiation.
     */
    public void setLowerLayerIfValue(String lowerLayerIfValue)
            throws JNCException {
        setLowerLayerIfValue(new InterfaceRef(lowerLayerIfValue));
    }

    /**
     * Deletes leaf-list entry "lowerLayerIf".
     * @param lowerLayerIfValue Value to delete.
     */
    public void deleteLowerLayerIf(InterfaceRef lowerLayerIfValue)
            throws JNCException {
        String path = "lowerLayerIf[lowerLayerIfValue]";
        delete(path);
    }

    /**
     * Deletes leaf-list entry "lowerLayerIf".
     * The value is specified as a string.
     * @param lowerLayerIfValue Value to delete.
     */
    public void deleteLowerLayerIf(String lowerLayerIfValue)
            throws JNCException {
        String path = "lowerLayerIf[lowerLayerIfValue]";
        delete(path);
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "lower-layer-if" leaf-list will not have a value.
     */
    public void addLowerLayerIf() throws JNCException {
        setLeafListValue(JIf.NAMESPACE,
            "lower-layer-if",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf-list "lower-layer-if" with operation "replace".
     * @param lowerLayerIfValue The value to mark
     */
    public void markLowerLayerIfReplace(InterfaceRef lowerLayerIfValue)
            throws JNCException {
        markLeafReplace("lowerLayerIf[name='" + lowerLayerIfValue + "']");
    }

    /**
     * Marks the leaf-list "lower-layer-if" with operation "merge".
     * @param lowerLayerIfValue The value to mark
     */
    public void markLowerLayerIfMerge(InterfaceRef lowerLayerIfValue)
            throws JNCException {
        markLeafMerge("lowerLayerIf[name='" + lowerLayerIfValue + "']");
    }

    /**
     * Marks the leaf-list "lower-layer-if" with operation "create".
     * @param lowerLayerIfValue The value to mark
     */
    public void markLowerLayerIfCreate(InterfaceRef lowerLayerIfValue)
            throws JNCException {
        markLeafCreate("lowerLayerIf[name='" + lowerLayerIfValue + "']");
    }

    /**
     * Marks the leaf-list "lower-layer-if" with operation "delete".
     * @param lowerLayerIfValue The value to mark
     */
    public void markLowerLayerIfDelete(InterfaceRef lowerLayerIfValue)
            throws JNCException {
        markLeafDelete("lowerLayerIf[name='" + lowerLayerIfValue + "']");
    }

    /* Access methods for optional leaf child: "speed". */

    /**
     * Gets the value for child leaf "speed".
     * @return The value of the leaf.
     */
    public Gauge64 getSpeedValue() throws JNCException {
        return (Gauge64)getValue("speed");
    }

    /**
     * Sets the value for child leaf "speed",
     * using a JNC type value.
     * @param speedValue The value to set.
     * @param speedValue used during instantiation.
     */
    public void setSpeedValue(Gauge64 speedValue) throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "speed",
            speedValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "speed",
     * using Java primitive values.
     * @param speedValue used during instantiation.
     */
    public void setSpeedValue(BigInteger speedValue) throws JNCException {
        setSpeedValue(new Gauge64(speedValue));
    }

    /**
     * Sets the value for child leaf "speed",
     * using a String value.
     * @param speedValue used during instantiation.
     */
    public void setSpeedValue(String speedValue) throws JNCException {
        setSpeedValue(new Gauge64(speedValue));
    }

    /**
     * Unsets the value for child leaf "speed".
     */
    public void unsetSpeedValue() throws JNCException {
        delete("speed");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "speed" leaf will not have a value.
     */
    public void addSpeed() throws JNCException {
        setLeafValue(JIf.NAMESPACE,
            "speed",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "speed" with operation "replace".
     */
    public void markSpeedReplace() throws JNCException {
        markLeafReplace("speed");
    }

    /**
     * Marks the leaf "speed" with operation "merge".
     */
    public void markSpeedMerge() throws JNCException {
        markLeafMerge("speed");
    }

    /**
     * Marks the leaf "speed" with operation "create".
     */
    public void markSpeedCreate() throws JNCException {
        markLeafCreate("speed");
    }

    /**
     * Marks the leaf "speed" with operation "delete".
     */
    public void markSpeedDelete() throws JNCException {
        markLeafDelete("speed");
    }

    /* Access methods for container child: "statistics". */

    /**
     * Adds container entry "statistics", using an existing object.
     * @param statistics The object to add.
     * @return The added child.
     */
    public Statistics addStatistics(Statistics statistics) throws JNCException {
        this.statistics = statistics;
        insertChild(statistics, childrenNames());
        return statistics;
    }

    /**
     * Adds container entry "statistics".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public Statistics addStatistics() throws JNCException {
        Statistics statistics = new Statistics();
        this.statistics = statistics;
        insertChild(statistics, childrenNames());
        return statistics;
    }

    /**
     * Deletes container entry "statistics".
     * @return An array of the deleted element nodes.
     */
    public NodeSet deleteStatistics() throws JNCException {
        this.statistics = null;
        String path = "statistics";
        return delete(path);
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
        if (child instanceof Statistics) statistics = (Statistics)child;
    }

}
