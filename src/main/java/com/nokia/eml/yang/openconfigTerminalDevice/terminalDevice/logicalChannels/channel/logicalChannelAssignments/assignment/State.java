/* 
 * @(#)State.java        1.0 15/06/18
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "openconfig-terminal-device", revision: "2017-07-08".
 */

package com.nokia.eml.yang.openconfigTerminalDevice.terminalDevice.logicalChannels.channel.logicalChannelAssignments.assignment;

import com.nokia.eml.yang.openconfigTerminalDevice.OcOptTerm;
import com.tailf.jnc.Element;
import com.tailf.jnc.JNCException;
import com.tailf.jnc.YangDecimal64;
import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt32;

import java.math.BigDecimal;

/**
 * This class represents an element from 
 * the namespace http://openconfig.net/yang/terminal-device
 * generated to "src/com/nokia/eml/yang/openconfigTerminalDevice/terminalDevice/logicalChannels/channel/logicalChannelAssignments/assignment/state"
 * <p>
 * See line 585 in
 * /root/nokia-yang/optical-transport/openconfig-terminal-device.yang
 *
 * @version 1.0 2018-06-15
 * @author Auto Generated
 */
public class State extends YangElement {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor for an empty State object.
     */
    public State() {
        super(OcOptTerm.NAMESPACE, "state");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public State clone() {
        return (State)cloneContent(new State());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public State cloneShallow() {
        return (State)cloneShallowContent(new State());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "index",
            "description",
            "assignment-type",
            "logical-channel",
            "optical-channel",
            "allocation",
        };
    }

    /* Access methods for optional leaf child: "index". */

    /**
     * Gets the value for child leaf "index".
     * @return The value of the leaf.
     */
    public YangUInt32 getIndexValue() throws JNCException {
        return (YangUInt32)getValue("index");
    }

    /**
     * Sets the value for child leaf "index",
     * using instance of generated typedef class.
     * @param indexValue The value to set.
     * @param indexValue used during instantiation.
     */
    public void setIndexValue(YangUInt32 indexValue) throws JNCException {
        setLeafValue(OcOptTerm.NAMESPACE,
            "index",
            indexValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "index",
     * using Java primitive values.
     * @param indexValue used during instantiation.
     */
    public void setIndexValue(long indexValue) throws JNCException {
        setIndexValue(new YangUInt32(indexValue));
    }

    /**
     * Sets the value for child leaf "index",
     * using a String value.
     * @param indexValue used during instantiation.
     */
    public void setIndexValue(String indexValue) throws JNCException {
        setIndexValue(new YangUInt32(indexValue));
    }

    /**
     * Unsets the value for child leaf "index".
     */
    public void unsetIndexValue() throws JNCException {
        delete("index");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "index" leaf will not have a value.
     */
    public void addIndex() throws JNCException {
        setLeafValue(OcOptTerm.NAMESPACE,
            "index",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "index" with operation "replace".
     */
    public void markIndexReplace() throws JNCException {
        markLeafReplace("index");
    }

    /**
     * Marks the leaf "index" with operation "merge".
     */
    public void markIndexMerge() throws JNCException {
        markLeafMerge("index");
    }

    /**
     * Marks the leaf "index" with operation "create".
     */
    public void markIndexCreate() throws JNCException {
        markLeafCreate("index");
    }

    /**
     * Marks the leaf "index" with operation "delete".
     */
    public void markIndexDelete() throws JNCException {
        markLeafDelete("index");
    }

    /* Access methods for optional leaf child: "description". */

    /**
     * Gets the value for child leaf "description".
     * @return The value of the leaf.
     */
    public YangString getDescriptionValue() throws JNCException {
        return (YangString)getValue("description");
    }

    /**
     * Sets the value for child leaf "description",
     * using instance of generated typedef class.
     * @param descriptionValue The value to set.
     * @param descriptionValue used during instantiation.
     */
    public void setDescriptionValue(YangString descriptionValue)
            throws JNCException {
        setLeafValue(OcOptTerm.NAMESPACE,
            "description",
            descriptionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "description",
     * using a String value.
     * @param descriptionValue used during instantiation.
     */
    public void setDescriptionValue(String descriptionValue)
            throws JNCException {
        setDescriptionValue(new YangString(descriptionValue));
    }

    /**
     * Unsets the value for child leaf "description".
     */
    public void unsetDescriptionValue() throws JNCException {
        delete("description");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "description" leaf will not have a value.
     */
    public void addDescription() throws JNCException {
        setLeafValue(OcOptTerm.NAMESPACE,
            "description",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "description" with operation "replace".
     */
    public void markDescriptionReplace() throws JNCException {
        markLeafReplace("description");
    }

    /**
     * Marks the leaf "description" with operation "merge".
     */
    public void markDescriptionMerge() throws JNCException {
        markLeafMerge("description");
    }

    /**
     * Marks the leaf "description" with operation "create".
     */
    public void markDescriptionCreate() throws JNCException {
        markLeafCreate("description");
    }

    /**
     * Marks the leaf "description" with operation "delete".
     */
    public void markDescriptionDelete() throws JNCException {
        markLeafDelete("description");
    }

    /* Access methods for optional leaf child: "assignment-type". */

    /**
     * Gets the value for child leaf "assignment-type".
     * @return The value of the leaf.
     */
    public YangEnumeration getAssignmentTypeValue() throws JNCException {
        return (YangEnumeration)getValue("assignment-type");
    }

    /**
     * Sets the value for child leaf "assignment-type",
     * using instance of generated typedef class.
     * @param assignmentTypeValue The value to set.
     * @param assignmentTypeValue used during instantiation.
     */
    public void setAssignmentTypeValue(YangEnumeration assignmentTypeValue)
            throws JNCException {
        setLeafValue(OcOptTerm.NAMESPACE,
            "assignment-type",
            assignmentTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "assignment-type",
     * using a String value.
     * @param assignmentTypeValue used during instantiation.
     */
    public void setAssignmentTypeValue(String assignmentTypeValue)
            throws JNCException {
        setAssignmentTypeValue(new YangEnumeration(assignmentTypeValue, new String[] {
             "LOGICAL_CHANNEL",
             "OPTICAL_CHANNEL",
        }));
    }

    /**
     * Unsets the value for child leaf "assignment-type".
     */
    public void unsetAssignmentTypeValue() throws JNCException {
        delete("assignment-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "assignment-type" leaf will not have a value.
     */
    public void addAssignmentType() throws JNCException {
        setLeafValue(OcOptTerm.NAMESPACE,
            "assignment-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "assignment-type" with operation "replace".
     */
    public void markAssignmentTypeReplace() throws JNCException {
        markLeafReplace("assignmentType");
    }

    /**
     * Marks the leaf "assignment-type" with operation "merge".
     */
    public void markAssignmentTypeMerge() throws JNCException {
        markLeafMerge("assignmentType");
    }

    /**
     * Marks the leaf "assignment-type" with operation "create".
     */
    public void markAssignmentTypeCreate() throws JNCException {
        markLeafCreate("assignmentType");
    }

    /**
     * Marks the leaf "assignment-type" with operation "delete".
     */
    public void markAssignmentTypeDelete() throws JNCException {
        markLeafDelete("assignmentType");
    }

    /* Access methods for optional leaf child: "logical-channel". */

    /**
     * Gets the value for child leaf "logical-channel".
     * @return The value of the leaf.
     */
    public YangUInt32 getLogicalChannelValue() throws JNCException {
        return (YangUInt32)getValue("logical-channel");
    }

    /**
     * Sets the value for child leaf "logical-channel",
     * using instance of generated typedef class.
     * @param logicalChannelValue The value to set.
     * @param logicalChannelValue used during instantiation.
     */
    public void setLogicalChannelValue(YangUInt32 logicalChannelValue)
            throws JNCException {
        setLeafValue(OcOptTerm.NAMESPACE,
            "logical-channel",
            logicalChannelValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "logical-channel",
     * using Java primitive values.
     * @param logicalChannelValue used during instantiation.
     */
    public void setLogicalChannelValue(long logicalChannelValue)
            throws JNCException {
        setLogicalChannelValue(new YangUInt32(logicalChannelValue));
    }

    /**
     * Sets the value for child leaf "logical-channel",
     * using a String value.
     * @param logicalChannelValue used during instantiation.
     */
    public void setLogicalChannelValue(String logicalChannelValue)
            throws JNCException {
        setLogicalChannelValue(new YangUInt32(logicalChannelValue));
    }

    /**
     * Unsets the value for child leaf "logical-channel".
     */
    public void unsetLogicalChannelValue() throws JNCException {
        delete("logical-channel");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "logical-channel" leaf will not have a value.
     */
    public void addLogicalChannel() throws JNCException {
        setLeafValue(OcOptTerm.NAMESPACE,
            "logical-channel",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "logical-channel" with operation "replace".
     */
    public void markLogicalChannelReplace() throws JNCException {
        markLeafReplace("logicalChannel");
    }

    /**
     * Marks the leaf "logical-channel" with operation "merge".
     */
    public void markLogicalChannelMerge() throws JNCException {
        markLeafMerge("logicalChannel");
    }

    /**
     * Marks the leaf "logical-channel" with operation "create".
     */
    public void markLogicalChannelCreate() throws JNCException {
        markLeafCreate("logicalChannel");
    }

    /**
     * Marks the leaf "logical-channel" with operation "delete".
     */
    public void markLogicalChannelDelete() throws JNCException {
        markLeafDelete("logicalChannel");
    }

    /* Access methods for optional leaf child: "optical-channel". */

    /**
     * Gets the value for child leaf "optical-channel".
     * @return The value of the leaf.
     */
    public YangString getOpticalChannelValue() throws JNCException {
        return (YangString)getValue("optical-channel");
    }

    /**
     * Sets the value for child leaf "optical-channel",
     * using instance of generated typedef class.
     * @param opticalChannelValue The value to set.
     * @param opticalChannelValue used during instantiation.
     */
    public void setOpticalChannelValue(YangString opticalChannelValue)
            throws JNCException {
        setLeafValue(OcOptTerm.NAMESPACE,
            "optical-channel",
            opticalChannelValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "optical-channel",
     * using a String value.
     * @param opticalChannelValue used during instantiation.
     */
    public void setOpticalChannelValue(String opticalChannelValue)
            throws JNCException {
        setOpticalChannelValue(new YangString(opticalChannelValue));
    }

    /**
     * Unsets the value for child leaf "optical-channel".
     */
    public void unsetOpticalChannelValue() throws JNCException {
        delete("optical-channel");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "optical-channel" leaf will not have a value.
     */
    public void addOpticalChannel() throws JNCException {
        setLeafValue(OcOptTerm.NAMESPACE,
            "optical-channel",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "optical-channel" with operation "replace".
     */
    public void markOpticalChannelReplace() throws JNCException {
        markLeafReplace("opticalChannel");
    }

    /**
     * Marks the leaf "optical-channel" with operation "merge".
     */
    public void markOpticalChannelMerge() throws JNCException {
        markLeafMerge("opticalChannel");
    }

    /**
     * Marks the leaf "optical-channel" with operation "create".
     */
    public void markOpticalChannelCreate() throws JNCException {
        markLeafCreate("opticalChannel");
    }

    /**
     * Marks the leaf "optical-channel" with operation "delete".
     */
    public void markOpticalChannelDelete() throws JNCException {
        markLeafDelete("opticalChannel");
    }

    /* Access methods for optional leaf child: "allocation". */

    /**
     * Gets the value for child leaf "allocation".
     * @return The value of the leaf.
     */
    public YangDecimal64 getAllocationValue() throws JNCException {
        return (YangDecimal64)getValue("allocation");
    }

    /**
     * Sets the value for child leaf "allocation",
     * using instance of generated typedef class.
     * @param allocationValue The value to set.
     * @param allocationValue used during instantiation.
     */
    public void setAllocationValue(YangDecimal64 allocationValue)
            throws JNCException {
        setLeafValue(OcOptTerm.NAMESPACE,
            "allocation",
            allocationValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "allocation",
     * using Java primitive values.
     * @param allocationValue used during instantiation.
     */
    public void setAllocationValue(BigDecimal allocationValue)
            throws JNCException {
        setAllocationValue(new YangDecimal64(allocationValue, 3));
    }

    /**
     * Sets the value for child leaf "allocation",
     * using a String value.
     * @param allocationValue used during instantiation.
     */
    public void setAllocationValue(String allocationValue) throws JNCException {
        setAllocationValue(new YangDecimal64(allocationValue, 3));
    }

    /**
     * Unsets the value for child leaf "allocation".
     */
    public void unsetAllocationValue() throws JNCException {
        delete("allocation");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "allocation" leaf will not have a value.
     */
    public void addAllocation() throws JNCException {
        setLeafValue(OcOptTerm.NAMESPACE,
            "allocation",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "allocation" with operation "replace".
     */
    public void markAllocationReplace() throws JNCException {
        markLeafReplace("allocation");
    }

    /**
     * Marks the leaf "allocation" with operation "merge".
     */
    public void markAllocationMerge() throws JNCException {
        markLeafMerge("allocation");
    }

    /**
     * Marks the leaf "allocation" with operation "create".
     */
    public void markAllocationCreate() throws JNCException {
        markLeafCreate("allocation");
    }

    /**
     * Marks the leaf "allocation" with operation "delete".
     */
    public void markAllocationDelete() throws JNCException {
        markLeafDelete("allocation");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
